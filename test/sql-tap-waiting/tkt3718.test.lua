#!/usr/bin/env tarantool
test = require("sqltester")
test:plan(10)

--!./tcltestrunner.lua
-- 2001 September 15
--
-- The author disclaims copyright to this source code.  In place of
-- a legal notice, here is a blessing:
--
--    May you do good and not evil.
--    May you find forgiveness for yourself and forgive others.
--    May you share freely, never taking more than you give.
--
-------------------------------------------------------------------------
-- This file implements regression tests for SQLite library.  The
-- focus of this file is testing the execution of SQL statements from
-- within callbacks generated by VMs that themselves open statement 
-- transactions.
--
-- $Id: tkt3718.test,v 1.2 2009/06/05 17:09:12 drh Exp $
-- ["set","testdir",[["file","dirname",["argv0"]]]]
-- ["source",[["testdir"],"\/tester.tcl"]]

test:do_execsql_test(
    "tkt3718-1.1",
    [[
        CREATE TABLE t1(a PRIMARY KEY, b);
        INSERT INTO t1 VALUES(1, 'one');
        INSERT INTO t1 VALUES(2, 'two');
        INSERT INTO t1 VALUES(3, 'three');
        INSERT INTO t1 VALUES(4, 'four');
        INSERT INTO t1 VALUES(5, 'five');
        CREATE TABLE t2(a PRIMARY KEY, b);
    ]], {
        -- <tkt3718-1.1>
        
        -- </tkt3718-1.1>
    })

-- SQL scalar function:
--
--   f1(<arg>)
--
-- Uses database handle [db] to execute "SELECT f2(<arg>)". Returns either
-- the results or error message from the "SELECT f2(<arg>)" query to the
-- caller.
--
local json = require("json")
local function f1(a)
    print("\n args "..json.encode(a))
    --a = test.lindex(args, 0)
    local msg = box.sql.execute("SELECT f2('"..a.."')")[1][1]
    print("\n ret "..json.encode(msg))
    return msg
end

-- SQL scalar function:
--
--   f2(<arg>)
--
-- Return the value of <arg>. Unless <arg> is "three", in which case throw
-- an exception.
--
local function f2(a)
    --a = test.lindex(args, 0)
    if (a == "three") then
        error("Three!!")
    end
    return a
end
box.internal.sql_create_function("f1", f1)
box.internal.sql_create_function("f2", f2)
--db("func", "f1", "f1")
--db("func", "f2", "f2")
-- The second INSERT statement below uses the f1 user function such that
-- half-way through the INSERT operation f1() will run an SQL statement
-- that throws an exception. At one point, before #3718 was fixed, this
-- caused the statement transaction belonging to the INSERT statement to
-- be rolled back. The result was that some (but not all) of the rows that 
-- should have been inserted went missing.
--
test:do_test(
    "tkt3718-1.2",
    function()
        test:execsql([[
            BEGIN;
            INSERT INTO t2 SELECT a, b FROM t1;
            INSERT INTO t2 SELECT a+5, f1(b) FROM t1;
            COMMIT;
        ]])
        return test:execsql([[
            SELECT a FROM t2;
        ]])
    end, {
        -- <tkt3718-1.2>
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        -- </tkt3718-1.2>
    })

-- This test turns on the count_changes pragma (causing DML statements to
-- return SQLITE_ROW once, with a single integer result value reporting the
-- number of rows affected by the statement). It then executes an INSERT
-- statement that requires a statement journal. After stepping the statement
-- once, so that it returns SQLITE_ROW, a second SQL statement that throws an
-- exception is run. At one point, before #3718 was fixed, this caused the
-- statement transaction belonging to the INSERT statement to be rolled back.
-- The result was that none of the rows were actually inserted.
-- 
--
test:do_test(
    "tkt3718-1.3",
    function()
        test:execsql([[
            DELETE FROM t2 WHERE a > 5;
            PRAGMA count_changes = 1;
            BEGIN;
        ]])
        test:execsql("INSERT INTO t2 SELECT a+5, b||'+5' FROM t1")
        local msg = test:execsql("SELECT f2('three')")
        return test:execsql([[
            COMMIT;
            SELECT a FROM t2;
        ]])
    end, {
        -- <tkt3718-1.3>
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        -- </tkt3718-1.3>
    })

test:do_execsql_test(
    "tkt3718-1.4",
    [[
        pragma count_changes=0
    ]], {
        -- <tkt3718-1.4>
        
        -- </tkt3718-1.4>
    })

-- This SQL function executes the SQL specified as an argument against
-- database [db].
--
local function sql(doit, zSql)
    if doit then
        test:catchsql(zSql)
    end
end
box.sql.internal.sql_create_function("sql", sql)
--db("func", "sql", { "sql" })
-- The following tests, tkt3718-2.*, test that a nested statement 
-- transaction can be successfully committed or reverted without 
-- affecting the parent statement transaction.
--
test:do_test(
    "tkt3718-2.1",
    function()
        test:execsql(" SELECT sql(1, 'DELETE FROM t2 WHERE a = '||a ) FROM t2 WHERE a>5 ")
        return test:execsql(" SELECT a from t2 ")
    end, {
        -- <tkt3718-2.1>
        1, 2, 3, 4, 5
        -- </tkt3718-2.1>
    })

test:do_test(
    "tkt3718-2.2",
    function()
        test:execsql([[
            DELETE FROM t2 WHERE a > 5;
            BEGIN;
            INSERT INTO t2 SELECT a+5, sql(a==3,
                'INSERT INTO t2 SELECT a+10, f2(b) FROM t1'
            ) FROM t1;
        ]])
        return test:execsql([[
            COMMIT;
            SELECT a FROM t2;
        ]])
    end, {
        -- <tkt3718-2.2>
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10
        -- </tkt3718-2.2>
    })

test:do_test(
    "tkt3718-2.3",
    function()
        test:execsql([[
            DELETE FROM t2 WHERE a > 5;
            BEGIN;
            INSERT INTO t2 SELECT a+5, sql(a==3,
                'INSERT INTO t2 SELECT a+10, b FROM t1'
            ) FROM t1;
            COMMIT;
        ]])
        return test:execsql(" SELECT a FROM t2 ORDER BY a+0")
    end, {
        -- <tkt3718-2.3>
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
        -- </tkt3718-2.3>
    })

--integrity_check tkt3718.2-4
-- The next set of tests, tkt3718-3.*, test that a statement transaction
-- that has a committed statement transaction nested inside of it can
-- be committed or reverted.
--
for _ in X(0, "X!foreach", [=[["tn io ii results","\n  1 0 10 {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20}\n  2 1 10 {6 7 8 9 10 16 17 18 19 20}\n  3 0 11 {1 2 3 4 5 6 7 8 9 10 16 17 18 19 20}\n  4 1 11 {6 7 8 9 10 16 17 18 19 20}\n"]]=]) do
    test:do_test(
        "tkt3718-3."..tn,
        function()
            test:execsql([[
                DELETE FROM t2;
                INSERT INTO t2 SELECT a+5, b FROM t1;
                INSERT INTO t2 SELECT a+15, b FROM t1;
            ]])
            test:catchsql(string.format([[
                BEGIN;
                INSERT INTO t2 SELECT a+%s, sql(a==3,
                    'INSERT INTO t2 SELECT a+%s, b FROM t1'
                ) FROM t1;
            ]], io, ii))
            test:execsql(" COMMIT ")
            return test:execsql(" SELECT a FROM t2 ORDER BY a+0")
        end, {
            results
        })

    --integrity_check tkt3718-3.$tn.integrity
end
-- This is the same test as tkt3718-3.*, but with 3 levels of nesting.
--
for _ in X(0, "X!foreach", [=[["tn i1 i2 i3 results","\n  1   0 10 20   {5 10 15 20 25 30}\n  2   0 10 21   {5 10 15 20 30}\n  3   0 11 20   {5 10 20 30}\n  4   0 11 21   {5 10 20 30}\n  5   1 10 20   {10 20 30}\n  6   1 10 21   {10 20 30}\n  7   1 11 20   {10 20 30}\n  8   1 11 21   {10 20 30}\n"]]=]) do
    test:do_test(
        "tkt3718-4."..tn,
        function()
            test:execsql([[
                DELETE FROM t2;
                INSERT INTO t2 SELECT a+5, b FROM t1;
                INSERT INTO t2 SELECT a+15, b FROM t1;
                INSERT INTO t2 SELECT a+25, b FROM t1;
            ]])
            test:catchsql(string.format([[
                BEGIN;
                INSERT INTO t2 SELECT a+%s, sql(a==3,
                    'INSERT INTO t2 SELECT a+%s, sql(a==3, 
                       ''INSERT INTO t2 SELECT a+%s, b FROM t1''
                     ) FROM t1'
                ) FROM t1;
            ]], i1, i2, i3))
            test:execsql(" COMMIT ")
            return test:execsql(" SELECT a FROM t2 WHERE (a%5)==0 ORDER BY a+0")
        end, {
            results
        })

    test:do_execsql_test(
        "tkt3718-4."..tn..".extra",
        [[
            SELECT 
              (SELECT sum(a) FROM t2)==(SELECT sum(a*5-10) FROM t2 WHERE (a%5)==0)
        ]], {
            1
        })

    --integrity_check tkt3718-4.$tn.integrity
end


test:finish_test()
