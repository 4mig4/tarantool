#!/usr/bin/env tarantool

--[[
=head1 NAME

tarantoolctl - an utility to control tarantool instances

=head1 SYNOPSIS

    vim /etc/tarantool/instances.enabled/my_instance.lua
    tarantoolctl start my_instance
    tarantoolctl stop my_instance
    tarantoolctl logrotate my_instance

=head1 DESCRIPTION

The script is read C</etc/sysconfig/tarantool> or C</etc/default/tarantool>.
The file contains common default instances options:

    $ cat /etc/default/tarantool
    -- Options for Tarantool
    default_cfg = {
        -- will become pid_file .. instance .. '.pid'
        pid_file    =   "/var/run/tarantool",
        -- will become wal_dir/instance/
        wal_dir     =   "/var/lib/tarantool",
        -- memtx_dir/instance/
        memtx_dir   =   "/var/lib/tarantool",
        -- vinyl_dir/instance/
        vinyl_dir   =   "/var/lib/tarantool/vinyl",
        -- log/instance .. '.log'
        log         =   "/var/log/tarantool",
        username    =   "tarantool",
    }
    instance_dir = "/etc/tarantool/instances.enabled"

The file defines C<instance_dir> where user can place his applications
(instances). Each instance can be controlled by C<tarantoolctl>:

=head2 Starting instance
    tarantoolctl start instance_name

=head2 Stopping instance
    tarantoolctl stop instance_name

=head2 Logrotate instance's log
    tarantoolctl logrotate instance_name

=head2 Enter instance admin console
    tarantoolctl enter instance_name

=head2 status
    tarantoolctl status instance_name

Check if instance is up.

If pid file exists and control socket exists and control socket is alive returns
code C<0>.

Return code != 0 in other cases. Can complain in log (stderr) if pid file exists
and socket doesn't, etc.

=head2 separate instances control

If You use SysV init, You can use symlink from C<tarantoolctl> to
C</etc/init.d/instance_name[.lua]>. C<tarantoolctl> detects if it is started by
symlink and uses instance_name as C<`basename $0 .lua`>.

=head1 COPYRIGHT

Copyright (C) 2010-2013 Tarantool AUTHORS:
please see AUTHORS file.

=cut
]]--

local ffi = require('ffi')
local fio = require('fio')
local fun = require('fun')
local log = require('log')
local json = require('json')
local errno = require('errno')
local argparse = require('internal.argparse').parse

local yaml  = require('yaml').new()
yaml.cfg{
    encode_invalid_numbers = true,
    encode_load_metatable = true,
    encode_use_tostring = true,
    encode_invalid_as_nil = true,
}

local tarantoolctl = nil

local function log_debug(fmt, ...)
    if tarantoolctl.verbosity > 0 then
        log.info(fmt, ...)
    end
end

local function log_traceback(level, ldepth)
    local function get_traceback(ldepth, level)
        local tb = {}
        local level = 2 + (ldepth or 1)
        while true do
            local info = debug.getinfo(level)
            assert(type(info) == 'nil' or type(info) == 'table')
            if info == nil then
                break
            end
            table.insert(tb, {
                line = info.currentline or 0,
                what = info.what or 'undef',
                file = info.short_src or info.src or 'eval',
                name = info.name,
            })
            level = level + 1
        end
        return tb
    end
    level = level and log[level] or log_debug
    for _, fr in ipairs(get_traceback(ldepth)) do
        local name = ''
        if fr.name ~= nil then
            name = (" function '%s'"):format(fr.name)
        end
        level("[%-4s]%s at <%s:%d>", fr.what, name, fr.file, fr.line)
    end
end

local function log_syserror(fmt, ...)
    if select('#', ...) > 0 then
        fmt = fmt:format(...)
    end
    log.error(
        string.format('[errno %d] %s: %s', errno(), fmt, errno.strerror())
    )
end

local function error(...)
    local fmt_pos, level = 2, 2
    local fmt = ...
    if type(fmt) == 'number' then
        fmt_pos = 3
        level, fmt = ...
    end
    -- format error message
    local stat = true
    if select('#', ...) >= fmt_pos then
        stat, fmt = pcall(
            string.format, select(fmt_pos - 1, ...)
        )
    end
    _G.error(fmt, stat == false and 2 or level)
end

local function syserror(...)
    local fmt_pos, level = 2, 2
    local fmt = ...
    if type(fmt) == 'number' then
        fmt_pos = 3
        level, fmt = ...
    end
    -- format error message
    fmt = '[errno %d] ' .. fmt .. ': ' .. errno.strerror()
    local stat, fmt = pcall(
        string.format, fmt, errno(), select(fmt_pos, ...)
    )
    _G.error(fmt, stat == false and 2 or level)
end

--------------------------------------------------------------------------------
--                                    ctl                                     --
--------------------------------------------------------------------------------

ffi.cdef[[
    typedef int uid_t;
    typedef int gid_t;
    typedef int time_t;

    uid_t getuid(void);

    struct group {
        char    *gr_name;    /* group name */
        char    *gr_passwd;  /* group password */
        gid_t    gr_gid;     /* group id */
        char   **gr_mem;     /* group members */
    };

    struct group *getgrgid(gid_t gid);
]]

if ffi.os == 'OSX' or ffi.os == 'BSD' then
    ffi.cdef[[
        struct passwd {
            char    *pw_name;    /* user name */
            char    *pw_passwd;  /* encrypted password */
            uid_t    pw_uid;     /* user uid */
            gid_t    pw_gid;     /* user gid */
            time_t   pw_change;  /* password change time */
            char    *pw_class;   /* user access class */
            char    *pw_gecos;   /* Honeywell login info */
            char    *pw_dir;     /* home directory */
            char    *pw_shell;   /* default shell */
            time_t   pw_expire;  /* account expiration */
            int      pw_fields;  /* internal: fields filled in */
        };
    ]]
else
    ffi.cdef[[
        struct passwd {
            char *pw_name;   /* username */
            char *pw_passwd; /* user password */
            int   pw_uid;    /* user ID */
            int   pw_gid;    /* group ID */
            char *pw_gecos;  /* user information */
            char *pw_dir;    /* home directory */
            char *pw_shell;  /* shell program */
        };
    ]]
end

ffi.cdef[[
    struct passwd *getpwuid(uid_t uid);
    struct passwd *getpwnam(const char *login);
]]


-- '/etc/default/tarantool'
local DEFAULT_DEFAULTS_PATH = '@CMAKE_INSTALL_FULL_SYSCONFDIR@/' ..
                              '@SYSCONFIG_DEFAULT@/tarantool'
-- '/etc/tarantool/plugins'
local DEFAULT_PLUGIN_PATH   = '@CMAKE_INSTALL_FULL_SYSCONFDIR@/' ..
                              'tarantool/plugins'
local DEFAULT_WRAPPER_NAME  = 'tarantoolctl'
local ENV_PLUGIN_PATH       = 'TARANTOOLCTL_PLUGIN_PATH'

--------------------------------------------------------------------------------
--                                 Utilities                                  --
--------------------------------------------------------------------------------

local user_cache = setmetatable({}, {
    __index = function(self, uid)
        local group_info, user_info, rv, gid = nil, nil, {}, -1
        do
            if type(uid) == 'number' then
                errno(0); user_info = ffi.C.getpwuid(uid)
                if user_info == nil then
                    if errno() == 0 then
                        log_debug("can't find user with uid '%d'", uid)
                    else
                        log.error("getpwuid failed [errno %d]: %s", errno(),
                                  errno.strerror())
                    end
                    return nil
                end
            elseif type(uid) == 'string' then
                errno(0); user_info = ffi.C.getpwnam(uid)
                if user_info == nil then
                    if errno() == 0 then
                        log_debug("can't find user with username '%s'", uid)
                    else
                        log.error("getpwnam failed [errno %d]: %s", errno(),
                                  errno.strerror())
                    end
                    return nil
                end
            else
                assert(false)
            end
            rv = {
                name = ffi.string(user_info.pw_name),
                uid  = tonumber(user_info.pw_uid),
                home = tonumber(user_info.pw_dir)
            }
        end
        do
            local gid = user_info.pw_gid
            errno(0); group_info = ffi.C.getgrgid(gid)
            if group_info ~= nil then
                rv.group = {
                    name = ffi.string(group_info.gr_name),
                    gid  =   tonumber(group_info.gr_gid)
                }
            else
                if errno() == 0 then
                    log_debug("can't find group with gid '%d'", gid)
                else
                    log.error("getgrgid failed [errno %d]: %s",
                              errno(), errno.strerror())
                end
            end
        end
        rawset(self, rv.uid, rv)
        rawset(self, rv.name, rv)
        return rv
    end
})

local function user_get(user)
    if user == nil then
        user = tonumber(ffi.C.getuid())
    end
    return user_cache[user]
end

local function is_main()
    return debug.getinfo(2).what == "main" and
           pcall(debug.getlocal, 5, 1) == false
end

local function execute_wrapped(func, ...)
    local function xpcall_traceback_callback(err)
        if err == 'usage' then
            return err
        end
        err = err or '<none>'
        if type(err) == 'cdata' then
            err = tostring(err)
        end
        local err_place = nil
        if err:match(':%d+: ') then
            err_place, err = err:match('(.+:%d+): (.+)')
        end
        log.error('Error catched: %s', err)
        if err_place ~= nil then
            log.error("Error occured at '%s'", err_place)
        end
        log.error('')
        log_traceback('error', 2)
        return err
    end

    return xpcall(func, xpcall_traceback_callback, ...)
end

local function is_callable(arg)
    if arg ~= nil then
        local mt = (type(arg) == 'table' and getmetatable(arg) or nil)
        if type(arg) == 'function' or mt ~= nil and
                                      type(mt.__call) == 'function' then
            return true
        end
    end
    return false
end

local function string_split(path, separator)
   local fields, separator = {}, separator or '.'
   path:gsub("([^" .. separator .. "]+)", function(c) table.insert(fields, c) end)
   return #fields, fields
end

local function split_config(path)
    local fields = {}
    path:gsub("([^.]+)", function(c) table.insert(fields, c) end)
    return #fields, fields
end

local function load_file_sandboxed(path, env, desc)
    path = fio.abspath(path)
    local ufunc, msg = loadfile(path)
    if not ufunc then
        log.error("Failed to load %s file '%s':", desc, path)
        log.error(msg)
        return false
    end
    debug.setfenv(ufunc, setmetatable(env, { __index = _G }))
    local rval = { execute_wrapped(ufunc) }
    if not rval[1] then
        log.error("Failed to execute %s file '%s':", desc, path)
        log.error(rval[2])
        return false
    end
    table.remove(rval, 1)
    return unpack(rval)
end

local function load_func_sandboxed(ufunc, env, desc)
    debug.setfenv(ufunc, setmetatable(env, { __index = _G }))
    local rval = { execute_wrapped(ufunc) }
    if not rval[1] then
        log.error("Failed to execute '%s' function:", desc)
        log.error(rval[2])
        return false
    end
    table.remove(rval, 1)
    return unpack(rval)
end

local function deepcopy(orig)
    local orig_type = type(orig)
    local copy = orig
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = deepcopy(orig_value)
        end
    end
    return copy
end

package.loaded['ctl.utils'] = {
    user_get        = user_get,
    string_split    = string_split,
    execute_wrapped = execute_wrapped,
    error           = error,
    syserror        = syserror,
    log_syserror    = log_syserror,
    log_debug       = log_debug,
}

--------------------------------------------------------------------------------
--                               Configuration                                --
--------------------------------------------------------------------------------

local function tarantoolctl_cfg_new()
    local cfg = {
        values = {},
        defaults = {},
        formats = setmetatable({
            lua = function(self, default_path)
                local function load_dictionary(self, name, value)
                    -- assume, that dicts have only string keys (for now)
                    name = name == nil and '' or name .. '.'
                    for subname, subvalue in pairs(value) do
                        subname = name .. subname
                        if type(subvalue) == 'table' then
                            load_dictionary(self, subname, subvalue)
                        else
                            self.values[subname] = subvalue
                        end
                    end
                end

                local result_environment = {}
                load_file_sandboxed(default_path, result_environment, 'defaults')
                load_dictionary(self, nil, result_environment)
            end
        }, {
            __index = function(self, format)
                self:error('unknown config format "%s"', format)
            end
        })
    }
    return setmetatable(cfg, {
        __index = {
            register = function(self, name, opts)
                opts = deepcopy(opts or {})
                self.defaults[name] = opts

            end,
            get = function(self, name)
                local def_value = self.defaults[name]
                if self.values[name] == nil then
                    local default = def_value.default
                    if is_callable(default) then default = default() end
                    self.values[name] = default
                end
                local value = self.values[name]
                if value == nil and def_value.deprecated ~= nil then
                    value = self.values[def_value.deprecated]
                    if value ~= nil then
                        log.error('using deprecated value "%s" (now called "%s")',
                                  def_value.deprecated, name)
                    end
                end
                local tp = def_value.type
                if value ~= nil and type(value) ~= tp then
                    log.error('config "%s": expected type "%s", got "%s"',
                              name, tp, type(value))
                    return nil
                end
                return value
            end,
            load = function(self, default_path)
                if default_path == nil then
                    return
                end
                local ext_len, ext = split_config(fio.basename(default_path))
                local format = ext_len > 1 and ext[ext_len] or 'lua'
                self.formats[format](self, default_path)
            end,
        },
    })
end

--------------------------------------------------------------------------------
--                        library/methods abstractions                        --
--------------------------------------------------------------------------------

local function usage_header()
    log.error("Tarantool client utility (%s)", _TARANTOOL)
    log.error("Usage:")
    log.error("")
end

-- split long line into muple one's with max width of 80 charachters and
-- prepends with depth spaces
local function print_aligned(lines, depth)
    local fields = {}
    if lines ~= nil then
        lines:gsub("([^\n]+)", function(val)
            local rv = val:gsub("^%s*(.-)%s*$", "%1")
            local fs = string.byte(rv, 1)
            if fs ~= 44 and fs ~= 46 and fs ~= 58 and fs ~= 59 then
                rv = ' ' .. rv
            end
            table.insert(fields, rv)
        end)
    end
    lines = table.concat(fields, '')
    fields = {}
    while true do
        if #lines == 0 then break end
        local line = nil
        if #lines <= 80 then
            line = lines
        else
            line = lines:sub(0, 80 - depth + 1):match("(.*%s)[^%s]*")
        end
        if not line or #line == 0 then
            line = lines:sub(0, 80 - depth) .. '-'
        end
        lines = lines:sub(#line + 1)
        line = line:gsub("^%s*(.-)%s*$", "%1")
        table.insert(fields, string.rep(' ', depth) .. line)
    end
    return fields
end

local tctl_method_methods = {
    run = function(self, context)
        log_debug("calling callback '%s'", self.name)
        local stat, rv = execute_wrapped(self.callback, context)
        if rv == 'usage' then
            return self:usage()
        end
        -- out:write(string.format('exiting "%s" "%s"\n', rv, self.opts.exiting))
        if self.opts.exiting or rv == false then
            os.exit(rv and 0 or 1)
        end
        return rv
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.depth = opts.depth

        local header = self.help.header
        if tarantoolctl.linkmode then
            if not self.help.linkmode then
                return
            end
            header = self.help.linkmode
        end
        if type(header) ~= 'table' then
            header = { header }
        end
        for _, line in ipairs(header) do
            line = line:format(tarantoolctl.program_name)
            local is_first_line = false
            for _, line in ipairs(
                print_aligned(line, opts.depth)
            ) do
                if is_first_line then line = '    ' .. line end
                log.info(line)
                is_first_line = true
            end
        end

        opts.detailed = opts.detailed or tarantoolctl.help
        if opts.detailed then
            local description = self.help.description
            log.info("")
            for _, line in ipairs(
                print_aligned(description, opts.depth + 2)
            ) do
                log.info(line)
            end
            local arguments   = self.help.arguments
            log.info("")
            if arguments then
                for _, arg in ipairs(arguments) do
                    log.info('%s%s', string.rep(' ', opts.depth + 2), arg[1])
                    for _, line in ipairs(
                        print_aligned(arg[2], opts.depth + 4)
                    ) do
                        log.info(line)
                    end
                end
                log.info("")
            end
        end
        return false
    end,
    plugin_api = function(self)
        return self
    end,
    public_api = function(self)
        return self
    end
}

local function tctl_method_new(name, callback, opts)
    -- checks must be here
    local help = opts.help
    opts.help = nil
    return setmetatable({
        name     = name,
        callback = callback,
        opts     = opts,
        help     = help
    }, {
        __index = tctl_method_methods
    })
end

local tctl_library_plugin_methods = {
    register_method  = function(self, name, callback, opts)
        log_debug("registering method '%s' for library '%s'", name, self.name)
        opts = deepcopy(opts or {})
        opts.help = opts.help or {}
        assert(type(opts.help.header) == 'string' or
               type(opts.help.header) == 'table')
        assert(type(opts.help.description) == 'string')
        if not opts.help.weight then
            opts.help.weight = fun.iter(self.methods):map(function(_, val)
                return val.help.weight
            end):chain({ 0 }):max() + 10
        end
        if self.methods[name] ~= nil then
            error('Method "%s" exists in "%s" library', name, self.name)
        end

        local meth_instance = tctl_method_new(name, callback, opts)
        self.methods[name] = meth_instance

        return meth_instance:plugin_api()
    end,
    register_prepare = function(self, name, callback)
        log_debug("registering context prepare function '%s'", name)
        if not is_callable(callback) then
            error('prepare function "%s" is not callable', name)
        end
        table.insert(self.prepare, {name, callback})
    end
}

local tctl_library_methods = {
    plugin_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_library_plugin_methods,
        })
    end,
    public_api = function(self)
        return self
    end,
    return_sorted = function(self)
        local sorted = fun.iter(self.methods):map(function(name, val)
            return {val.help.weight or 0, name}
        end):totable();
        table.sort(sorted, function(l, r) return l[1] < r[1] end)
        return fun.iter(sorted):map(function(value)
            return self.methods[value[2]]
        end):totable()
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.depth    = opts.depth    or 0
        opts.detailed = opts.detailed or tarantoolctl.help
        local nested = opts.nested
        local depth  = opts.depth

        if tarantoolctl.linkmode then
            local have_linkmode = false
            for name, method in pairs(self.methods) do
                if method.help.linkmode then
                    have_linkmode = true
                    break
                end
            end
            if not have_linkmode then
                if not opts.nested then
                    log.error("%s library doesn't support link mode", self.name)
                end
                return false
            end
        end

        if self.command == nil then
            if nested then
                log.info("%s[%s library]", string.rep(' ', depth), self.name)
            else
                log.error("Expected command name, got nothing")
            end
        elseif self.methods[self.command] == nil then
            log.error("Command '%s' isn't found in module '%s'",
                      self.command, self.name)
        end
        if not nested then
            log.error("")
            usage_header()
        end
        opts.depth = opts.depth + 4
        for _, val in ipairs(self:return_sorted()) do
            val:usage(opts)
            opts.first = true
        end
        opts.depth = opts.depth - 4
        return false
    end,
    run = function(self)
        self.command = table.remove(self.arguments, 1)
        if self.command == nil then
            return self:usage()
        end
        local wrapper = self.methods[self.command]
        if wrapper == nil or tarantoolctl.help then
            return self:usage()
        end
        do -- prepare context here
            self.context.command = self.command
            self.context.positional_arguments = {}
            self.context.keyword_arguments    = {}
            for k, v in pairs(tarantoolctl.arguments) do
                if type(k) == 'number' then
                    self.context.positional_arguments[k] = v
                else
                    self.context.keyword_arguments[k] = v
                end
            end
            for _, prepare in ipairs(self.prepare) do
                local name, cb = unpack(prepare)
                log_debug("running context prepare function '%s'", name)
                if cb(tarantoolctl:public_api(), self.context) == false then
                    return self:usage()
                end
            end
        end
        return wrapper:run(self.context)
    end,
}

local function tctl_library_new(name, opts)
    local help = opts.help
    opts.help = nil
    return setmetatable({
        name        = name,
        command     = nil,
        methods     = {},
        prepare     = {},
        context     = {},
        arguments   = tarantoolctl.arguments,
        opts        = opts,
        help        = help
    }, {
        __index = tctl_library_methods,
    })
end

local function find_defaults_file_user()
    local user = user_get()
    log_debug('user with uid "%d" is used', user.uid)
    if user.uid ~= 0 then
        -- check in current directory
        local defaults = fio.pathjoin(fio.cwd(), '.tarantoolctl')
        log_debug('defaults file: trying to find "%s"', defaults)
        if fio.stat(defaults) then
            return true, defaults
        end
        -- check in home directory
        defaults = os.getenv('HOME')
        if defaults ~= nil then
            defaults = fio.pathjoin(defaults, '.config/tarantool/tarantool')
            log_debug('defaults file: trying to find "%s"', defaults)
            if fio.stat(defaults) then
                return true, defaults
            end
        end
    end
    -- we wern't been able to found tarantoolctl config in local/home
    -- directories (or we're 'root')
    return false, nil
end

local function find_defaults_file()
    -- try to find local/user configuration
    local user, defaults = find_defaults_file_user()
    if user == false then
        -- try to find system-wide configuration
        defaults = DEFAULT_DEFAULTS_PATH
        log_debug('defaults file: trying to find "%s"', defaults)
        if not fio.stat(defaults) then
            defaults = nil
        end
    end

    if defaults == nil then
        log_debug("can't find defaults file.")
    else
        log_debug('using "%s" as defaults file', defaults)
    end
    -- no defaults path, assume defaults
    return user, defaults
end

local tctl_plugin_methods = {
    register_library = function(self, name, opts)
        log_debug("registering library '%s'", name)
        opts = deepcopy(opts or {})
        opts.help = opts.help or {}
        if self.libraries[name] ~= nil then
            log.error("failed to register library. already exists")
            return nil
        end
        if not opts.help.weight then
            opts.help.weight = fun.iter(self.libraries):map(function(_, val)
                return val.help.weight
            end):chain({ 0 }):max() + 10
        end

        local lib_instance = tctl_library_new(name, opts)
        self.libraries[name] = lib_instance

        return lib_instance:plugin_api()
    end,
    register_alias   = function(self, name, dotted_path, cfg)
        log_debug("registering alias '%s' to '%s'", name, dotted_path)
        local n, path = split_config(dotted_path)
        local lname, mname = unpack(path)
        if n ~= 2 then
            log.error("bad alias path '%s' (expected 2 components, got %d)",
                      dotted_path, n)
            return nil
        end
        local library = self.libraries[lname]
        if library == nil then
            log.error("bad alias path '%s' (library '%s' not found)",
                      dotted_path, lname)
            return nil
        end
        local method = library.methods[mname]
        if method == nil then
            log.error("bad alias path '%s' (method '%s' not found)",
                      dotted_path, lname)
            return nil
        end

        cfg = cfg or {}

        self.aliases[name] = {
            path = dotted_path,
            deprecated = cfg.deprecated or false
        }

        return method:plugin_api()
    end,
    register_config  = function(self, name, opts)
        log_debug("registering configuration value '%s'", name)
        if opts.deprecated then
            log_debug("deprecated name: %s", opts.deprecated)
        end
        if opts.type then
            log_debug("expected type:   %s", opts.type)
        end
        if opts.default then
            log_debug("default value:   %s", opts.default)
        end
        self.cfg:register(name, opts)
    end
}

local tctl_public_methods = {
    get_config = function(self, name)
        log_debug("getting configuration value for '%s'", name)
        return self.cfg:get(name)
    end
}

local tctl_methods = {
    load_defaults = function(self)
        self.usermode, self.defaults = find_defaults_file()
        self.cfg:load(self.defaults)
    end,
    load_plugin = function(self, n, file, count)
        local function plugin_count_len(n, count)
            local cnt = #tostring(count)
            return string.format('%0'.. cnt .. 'd/%0' .. cnt .. 'd', n, count)
        end

        file = fio.abspath(file)
        log_debug("loading plugin %s '%s'", plugin_count_len(n, count), file)
        load_file_sandboxed(file, {}, 'plugins')
    end,
    load_plugin_list = function(self, plugins)
        local plugin_cnt = #plugins
        log_debug("found %d plugin files", plugin_cnt)
        for n, file in ipairs(plugins) do
            self:load_plugin(n, file, plugin_cnt)
        end
    end,
    load_plugin_directory = function(self, plugin_dir_path)
        log_debug("loading plugins from '%s'", plugin_dir_path)

        if fio.stat(plugin_dir_path) == nil then
            log_debug("error: failed to open path '%s'", plugin_dir_path)
            return nil
        end

        local re_plugins = fio.pathjoin(plugin_dir_path, '*.lua')
        local plugins = fio.glob(re_plugins)

        return self:load_plugin_list(plugins)
    end,
    load_plugin_package_path_patterns = function(self)
        log_debug("loading plugins from package.path")

        local path_pattern = package.path:gsub('?', '*/tarantoolctl')
        local pattern_list = {}
        for pattern in path_pattern:gmatch('([^;]+);') do
            table.insert(pattern_list, pattern)
        end
        local plugins = {}
        for _, re in ipairs(pattern_list) do
            log_debug("matching pattern '%s'", re)
            local matched_plugins = fio.glob(re)
            for _, name in ipairs(matched_plugins) do
                log_debug("found plugin: '%s'", name)
                table.insert(plugins, name)
            end
        end

        return self:load_plugin_list(plugins)
    end,
    plugin_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_plugin_methods,
        })
    end,
    load_plugins = function(self)
        package.loaded['ctl'] = self:plugin_api()
        local plugin_path = os.getenv(ENV_PLUGIN_PATH)
        if plugin_path ~= nil then
            self:load_plugin_directory(plugin_path)
        end
        self:load_plugin_package_path_patterns()
        package.loaded['ctl'] = nil
    end,
    public_api = function(self)
        return setmetatable(fun.iter(self):tomap(), {
            __index = tctl_public_methods,
        })
    end,
    usage = function(self, opts)
        opts = opts or {}
        opts.detailed = opts.detailed or false
        opts.depth    = opts.depth    or 0
        opts.header   = opts.header   or false

        if self.command ~= nil then
            log.error("Unknown library or command name '%s'", self.command)
            log.error("")
        end

        usage_header()

        local sorted = fun.iter(self.libraries):map(function(name, val)
            return {val.help.weight or 0, name}
        end):totable();

        table.sort(sorted, function(l, r) return l[1] < r[1] end)
        opts.depth = opts.depth + 4
        opts.nested = true
        local lsorted = #sorted
        fun.iter(sorted):enumerate():each(function(n, val)
            local rv = self.libraries[val[2]]:usage(opts)
            if rv ~= nil then log.info("") end
        end)
        opts.depth = opts.depth - 4
        return false
    end,
    run = function(self)
        self.command = table.remove(self.arguments, 1)
        if self.command == nil then
            return self:usage()
        end
        log_debug('running %s', self.command)
        local alias = self.aliases[self.command]
        if alias ~= nil then
            local _, path = split_config(alias.path)
            table.insert(self.arguments, 1, path[2])
            self.command = path[1]
        end
        local wrapper = self.libraries[self.command]
        if wrapper == nil then
            return self:usage()
        end
        return wrapper:run()
    end,
}

tarantoolctl = setmetatable({
    libraries = {},
    aliases   = {},
    plugins   = {},
    cfg = tarantoolctl_cfg_new(),
}, {
    __index = tctl_methods
})
local function is_linkmode(program_name)
    return not (fio.basename(program_name, '.lua') == DEFAULT_WRAPPER_NAME)
end

local function runner(tctl)
    -- make copy of arguments for modification
    tctl.executable   = arg[-1]
    tctl.program_name = arg[ 0]
    tctl.arguments    = argparse(arg)
    tctl.linkmode     = is_linkmode(tctl.program_name)
    tctl.help         = false
    if tctl.arguments.h or tctl.arguments.help then
        tctl.help     = true
    end

    -- we shouldn't throw errors until this place.
    -- output before that point is kinda buggy
    local v = tctl.arguments.v; v = type(v) ~= 'table' and { v } or v
    tctl.verbosity = #v

    tctl:load_defaults()
    tctl:load_plugins()

    local rv = tctl:run()
    if tctl.exiting or rv == false then
        os.exit(rv and 0 or 1)
    end
end

if is_main() then
    execute_wrapped(runner, tarantoolctl, arg)
else
    -- return table for testing
    return {}
end

-- vim: syntax=lua
